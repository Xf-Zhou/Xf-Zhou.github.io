<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#6200ee"><meta name="author" content="xfzhou"><meta name="copyright" content="xfzhou"><meta name="generator" content="Hexo 4.2.1"><meta name="theme" content="hexo-theme-yun"><title>面向对象 | 恍惚斋</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;family=Source+Code+Pro&amp;display=swap" media="none" onload="this.media='all'"><script src="//at.alicdn.com/t/font_1140697_pem9yni52s.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="shortcut icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#6200ee"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"root":"/","title":"恍惚斋","version":"0.9.0","anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["104, 100, 189","93, 175, 189","11, 163, 42"]}};
  </script><meta name="description" content="面向对象面向过程  步骤清晰简单，第一步做什么，第二步做什么…… 面对过程适合处理一些较为简单的问题  面向对象  物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。 面向对象适合处理复杂的问题，适合处理需要多人协作的问题！  对于描述复杂的事物，为了从宏观上把握（从整体上合理划分），我们需要使用面向对象的思路来">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象">
<meta property="og:url" content="https://xfzhou95.com/2020/11/23/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="恍惚斋">
<meta property="og:description" content="面向对象面向过程  步骤清晰简单，第一步做什么，第二步做什么…… 面对过程适合处理一些较为简单的问题  面向对象  物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。 面向对象适合处理复杂的问题，适合处理需要多人协作的问题！  对于描述复杂的事物，为了从宏观上把握（从整体上合理划分），我们需要使用面向对象的思路来">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="d:%5CBlog%5Csource%5Cimages%5C%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90.png">
<meta property="og:image" content="d:%5CBlog%5Csource%5Cimages%5C%E7%BB%A7%E6%89%BF%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B.png">
<meta property="og:image" content="d:%5CBlog%5Csource%5Cimages%5C%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97.png">
<meta property="og:image" content="d:%5CBlog%5Csource%5Cimages%5Cimage-20201124225946466.png">
<meta property="og:image" content="d:%5CBlog%5Csource%5Cimages%5C%E6%8A%BD%E8%B1%A1%E7%B1%BB.png">
<meta property="og:image" content="d:%5CBlog%5Csource%5Cimages%5C%E6%8E%A5%E5%8F%A3.png">
<meta property="og:image" content="d:%5CBlog%5Csource%5Cimages%5C%E6%8E%A5%E5%8F%A32.png">
<meta property="article:published_time" content="2020-11-23T02:12:26.167Z">
<meta property="article:modified_time" content="2020-11-27T07:21:00.549Z">
<meta property="article:author" content="xfzhou">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:%5CBlog%5Csource%5Cimages%5C%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90.png"><script src="/js/ui/mode.js"></script><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle sidebar-toggle-fixed hty-icon-button"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><aside class="sidebar"><script defer src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="xfzhou"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="xfzhou"></a><div class="site-author-name"><a href="/about/">xfzhou</a></div><a class="site-name" href="/about/site.html">恍惚斋</a><sub class="site-subtitle"></sub><div class="site-desciption">面壁十年图破壁</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">20</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">3</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">13</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/Xf-Zhou" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:2102813085@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象"><span class="toc-number">1.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是面向对象"><span class="toc-number">1.1.</span> <span class="toc-text">什么是面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建和初始化对象"><span class="toc-number">1.2.</span> <span class="toc-text">创建和初始化对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象内存分析"><span class="toc-number">1.3.</span> <span class="toc-text">对象内存分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简单小结"><span class="toc-number">1.4.</span> <span class="toc-text">简单小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#封装"><span class="toc-number">1.5.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承"><span class="toc-number">1.6.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法重写"><span class="toc-number">1.7.</span> <span class="toc-text">方法重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态"><span class="toc-number">1.8.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static关键字"><span class="toc-number">1.9.</span> <span class="toc-text">static关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类"><span class="toc-number">1.10.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口"><span class="toc-number">1.11.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类"><span class="toc-number">1.12.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#匿名内部类"><span class="toc-number">1.12.1.</span> <span class="toc-text">匿名内部类</span></a></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://xfzhou95.com/2020/11/23/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="xfzhou"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="恍惚斋"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">面向对象<a class="post-edit-link" href="https://github.com/Xf-Zhou/Xf-Zhou.github.io/tree/hexo/source/_posts/面向对象.md" target="_blank" title="编辑" rel="noopener"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-edit-line"></use></svg></a></h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2020-11-23 10:12:26" itemprop="dateCreated datePublished" datetime="2020-11-23T10:12:26+08:00">2020-11-23</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2020-11-27 15:21:00" itemprop="dateModified" datetime="2020-11-27T15:21:00+08:00">2020-11-27</time></div><span class="leancloud_visitors" id="/2020/11/23/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" data-flag-title="面向对象"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读次数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span class="leancloud-visitors-count"></span></span></span><div class="post-classify"></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content post-markdown"><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><strong>面向过程</strong></p>
<ul>
<li>步骤清晰简单，第一步做什么，第二步做什么……</li>
<li>面对过程适合处理一些较为简单的问题</li>
</ul>
<p><strong>面向对象</strong></p>
<ul>
<li>物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。</li>
<li>面向对象适合处理复杂的问题，适合处理需要多人协作的问题！</li>
</ul>
<p><strong>对于描述复杂的事物，为了从宏观上把握（从整体上合理划分），我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。</strong></p>
<h3 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h3><blockquote>
<p>面向对象编程（Object-Oriented Programming，OOP）</p>
<p>面向对象编程的本质就是：<strong>以类的方式组织代码，以对象的组织（封装）数据。</strong></p>
</blockquote>
<p>特点：</p>
<ul>
<li><strong>抽象</strong></li>
<li>三大特性：<strong>封装、继承、多态</strong></li>
</ul>
<blockquote>
<p>从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象</p>
<p>从代码运行角度考虑是先有类后有对象。类是对象的模板。</p>
</blockquote>
<p>回顾方法：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*
修饰符  返回值类型/void  方法名（...){
    //方法体
    return 返回值;
}
*/</span></code></pre>
<p><strong>static 修饰方法代表静态方法，和类一起加载，非静态方法要在类实例化之后才存在。</strong></p>
<p>所以在类中不能直接调用非静态方法。</p>
<p>Java是<strong>值传递</strong>。</p>
<h3 id="创建和初始化对象"><a href="#创建和初始化对象" class="headerlink" title="创建和初始化对象"></a>创建和初始化对象</h3><p>使用new关键字：</p>
<ul>
<li>使用new关键字创建的时候，除了<strong>分配内存空间</strong>之外，还会给<strong>创建好的对象进行默认的初始化</strong>以及对类中构造器的调用。</li>
<li>类中的<strong>构造器也称为构造方法</strong>，是在进行<strong>创建对象</strong>的时候<strong>必须要调用</strong>的。并且构造器有以下俩个特点：<ul>
<li>必须和类的名字相同</li>
<li>必须没有返回类型，也不能写void</li>
</ul>
</li>
</ul>
<p>构造器作用：</p>
<ul>
<li>使用new关键字，本质是在调用构造器</li>
<li>初始化对象的值</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>

    String name<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//实例化初始值</span>
    <span class="token comment" spellcheck="true">//1.使用new关键字，本质是在调用构造器</span>
    <span class="token comment" spellcheck="true">//2.构造器一般用来初始化值</span>
    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//有参构造：一旦定义了有参构造，想使用无参构造，就必须显式地定义无参构造(方法重载）</span>
    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/*
public class Application {
    public static void main(String[] args) {

        Person person = new Person("kuang");
        System.out.println(person.name);
    }
    构造器：
        1．和类名相同
        2.没有返回值
    作用：
        1.new本质在调用构造方法
        2.初始化对象的值
    注意点：
    1.定义有参构造之后，如果想使用无参构选，显式的定义一个无参的构选
    2.如果我们没有显示定义构造器，编译器会自动给我们生成一个无参地构造器。
}*/</span></code></pre>
<h3 id="对象内存分析"><a href="#对象内存分析" class="headerlink" title="对象内存分析"></a>对象内存分析</h3><pre class=" language-java"><code class="language-java">
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pet</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> String name<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"叫了一声"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/*
import com.kuangstudy.oop.demo03.Pet;

public class Application {
    public static void main(String[] args) {

        Pet dog = new Pet();
        dog.name = "旺财";
        dog.age = 3;
        dog.shout();

        System.out.println(dog.name);
        System.out.println(dog.age);
    }
}*/</span></code></pre>
<p><img src="D:%5CBlog%5Csource%5Cimages%5C%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90.png" alt="img" loading="lazy"></p>
<p>注意：方法区也是在堆中。</p>
<p>栈中dog相当于一个容器，存放着对象的地址，通过这个地址去找到堆中所对应的对象，相当于通过一个人的名字找到一个人。</p>
<h3 id="简单小结"><a href="#简单小结" class="headerlink" title="简单小结"></a>简单小结</h3><ol>
<li>类与对象</li>
</ol>
<p>​        类是一个模板：抽象，对象是一个具体的实例</p>
<ol start="2">
<li>方法</li>
</ol>
<p>​        定义、调用！</p>
<ol start="3">
<li>对应的引用</li>
</ol>
<p>​        引用类型：基本类型（8）<br>​        对象是通过引用来操作的：栈–→&gt;堆</p>
<ol start="4">
<li><p>属性：字段属性：字段Field   成员变量</p>
<p><strong>默认初始化：</strong></p>
<pre><code>    数字：0   0.0
    char：u0000
    boolean：false
    引用类型：null</code></pre><p>修饰符   属性类型    属性名=属性值！</p>
</li>
<li><p>对象的创建和使用</p>
<ul>
<li><p>必须使用new关键字创造对象，构造器<code>Person kuangshen = new Person();</code></p>
</li>
<li><p>对象的属性  <code>kuangshen.name；</code></p>
</li>
<li><p>对象的方法  <code>kuangshen.sleep</code></p>
</li>
</ul>
</li>
<li><p>类</p>
<p>  静态的属性    属性</p>
<p>  动态的行为   方法</p>
</li>
</ol>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul>
<li><strong>该露的露，该藏的藏</strong><ul>
<li>程序设计要追求”高内聚，低耦合”。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用。</li>
</ul>
</li>
<li><strong>封装（数据的隐藏）</strong><ul>
<li>通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称为信息隐藏。</li>
</ul>
</li>
<li><strong>记住这句话就够了：属性私有，get/set</strong></li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*作用
1.提高程序的安全性，保护数据
2.隐藏代码的实现细节
3.统一接口
4．系统可维护增加了*/</span>

<span class="token comment" spellcheck="true">//private :私有</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//属性私有</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">char</span> sex<span class="token punctuation">;</span>


    <span class="token comment" spellcheck="true">//提供一些可以操作这个属性的方法！public的get、set方法</span>
    <span class="token comment" spellcheck="true">//get获取属性</span>
    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//set设置属性</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/*
import com.kuangstudy.oop.demo04.Student;

public class Application {
    public static void main(String[] args) {

        Student s1 = new Student();
        s1.setName("zx");
        System.out.println(s1.getName());
    }
}*/</span></code></pre>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。</li>
<li><strong>extends</strong>的意思是“扩展”。子类是父类的扩展。</li>
<li>JAVA中类只有单继承，没有多继承！一个儿子只能有一个爸爸，但是一个爸爸可以有多个儿子。</li>
<li>继承是类和类之间的一种关系。除此之外类和类之间的关系还有依赖、组合、聚合等。</li>
<li>继承关系的俩个类，一个为子类（派生类），一个为父类（基类），子类继承父类，使用关键字extends来表示。</li>
<li>子类和父类之间从意义上讲应该具有”is a”的关系.</li>
</ul>
<p><strong>super：代表父类对象    this：代表当前对象，私有的无法被继承</strong></p>
<p>super注意点：</p>
<ol>
<li><p>super调用父类的构造方法，必须在构造方法的第一个。</p>
</li>
<li><p>super必须只能出现在子类的方法或者构造方法中！</p>
</li>
<li><p>super和this不能同时调用构造方法！</p>
</li>
</ol>
<p>Vs this：</p>
<ol>
<li><p>代表的对象不同：</p>
<ul>
<li>this：本身调用者这个对象</li>
<li>super：代表父类对象的应用</li>
</ul>
</li>
<li><p>前提</p>
<ul>
<li>this：没有继承也可以使用</li>
<li>super：只能在继承条件才可以使用</li>
</ul>
</li>
<li><p>构造方法</p>
<ul>
<li>this（）；本类的构造d</li>
<li>super（）：父类的构造！</li>
</ul>
</li>
</ol>
<p><img src="D:%5CBlog%5Csource%5Cimages%5C%E7%BB%A7%E6%89%BF%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B.png" alt="img" loading="lazy"></p>
<p>注意：通过<code>final</code>修饰符修饰的类无法被继承，相当于断子绝孙了！</p>
<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//static</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//静态的变量</span>
    <span class="token keyword">private</span> <span class="token keyword">double</span> score<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">go</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">go</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Student s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Student<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//System.out.println(Student.score); // 无法通过类直接读取非静态变量</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">go</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//run();无法直接调用非静态方法</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>静态代码块</p>
<p><img src="D:%5CBlog%5Csource%5Cimages%5C%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97.png" alt="image-20201124225751323" loading="lazy"></p>
<p><img src="D:%5CBlog%5Csource%5Cimages%5Cimage-20201124225946466.png" alt="image-20201124225946466" loading="lazy"></p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li><strong>abstract</strong>修饰符可以用来修饰方法也可以修饰类，如果修饰方法，那么该方法就是抽象方法如果修饰类，那么该类就是抽象类。</li>
<li>抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。</li>
<li>抽象类，不能使用new关键字来创建对象，它是用来让子类继承的。</li>
<li>抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的。</li>
<li>子类继承抽象类，那么就必须要实现抽象类没有实现的抽象方法，否则该子类也要声明为抽象类。</li>
</ul>
<p><img src="D:%5CBlog%5Csource%5Cimages%5C%E6%8A%BD%E8%B1%A1%E7%B1%BB.png" alt="img" loading="lazy"></p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>普通类：只有具体实现</li>
<li>抽象类：具体实现和规范（抽象方法）都有！</li>
<li>接口：只有规范！自己无法写方法，专业的约束！约束和实现分离：面向接口编程~</li>
<li>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是 则必须能.”的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。如果你好人，则必须干掉坏人；如果你是坏人，则必须欺负好人。</li>
<li><strong>接口的本质是契约</strong>，就像我们人间的法律一样。制定好后大家都遵守。</li>
<li>OO的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言（比如c++、java，c#等），就是因为设计模式所研究的，实际上就是如何合理的去抽象。</li>
</ul>
<p><strong>声明类的关键字是class，声明接口的关键字是interface</strong></p>
<p><img src="D:%5CBlog%5Csource%5Cimages%5C%E6%8E%A5%E5%8F%A3.png" alt="img" loading="lazy"></p>
<p><img src="D:%5CBlog%5Csource%5Cimages%5C%E6%8E%A5%E5%8F%A32.png" alt="img" loading="lazy"></p>
<p><strong>接口的作用</strong></p>
<ol>
<li>约束</li>
<li>定义一些方法，让不同的人实现~ 10—&gt; 1</li>
<li>方法默认都是 <code>public abstract</code></li>
<li>常量都是 <code>public static final</code></li>
<li>接口不能被实例化，接口中没有构造方法~</li>
<li>implements可以实现多个接口</li>
<li>必须要重写接口中的方法</li>
</ol>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>通过接口实现</p>
<p>匿名内部类也是不能有访问修饰符和 static 修饰符的。</p>
<p>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调</p>
<p>匿名内部类在编译的时候由系统自动起名为 Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LambdaDemo2</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        Ilove love <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Ilove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">love</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i love you -->"</span> <span class="token operator">+</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        love<span class="token punctuation">.</span><span class="token function">love</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token keyword">interface</span> <span class="token class-name">Ilove</span><span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">love</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">如果喜欢就点赞or赞赏</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="https://cdn.jsdelivr.net/gh/xf-zhou/CDN/img/donate/alipay-qrcode.jpg" target="_blank" rel="noopener"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/xf-zhou/CDN/img/donate/alipay-qrcode.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="https://cdn.jsdelivr.net/gh/xf-zhou/CDN/img/donate/wechatpay-qrcode.png" target="_blank" rel="noopener"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/xf-zhou/CDN/img/donate/wechatpay-qrcode.png" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>xfzhou</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://xfzhou95.com/2020/11/23/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="面向对象">https://xfzhou95.com/2020/11/23/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2020/11/26/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/" rel="prev" title="注解和反射"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">注解和反射</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2020/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/" rel="next" title="数据结构常用方法"><span class="post-nav-text">数据结构常用方法</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"><span>点击按钮跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br><a class="hty-button hty-button--raised" id="github-issues" href="https://github.com/YunYouJun/yunyoujun.github.io/issues?q=is:issue+面向对象" target="_blank" rel="noopener">GitHub Issues</a></div><div id="valine-container"></div><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function initValine() {
  const valineConfig = {"enable":true,"appId":"Ly4ohwKW5DOjAswrfhXkSbDp-gzGzoHsz","appKey":"7JcswEnhHmu9mlhqlDVWRzon","placeholder":"说点什么","avatar":null,"meta":["nick","mail","link"],"pageSize":10,"visitor":true,"recordIP":true,"enableQQ":true,"requiredFields":["nick","mail"],"highlight":true,"el":"#valine-container","lang":"zh-cn"}
  valineConfig.path = window.location.pathname
  new Valine(valineConfig)
}
setTimeout(initValine, 1000)</script></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2020 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-user-line"></use></svg></span><span class="author"> xfzhou</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v4.2.1</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v0.9.0</span></div><div class="live_time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  window.setTimeout(blog_live_time, 1000);
  const start = new Date('2019-06-19T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#6200ee" stroke-width="2" stroke-linecap="round"></circle></svg></a></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script></body></html>